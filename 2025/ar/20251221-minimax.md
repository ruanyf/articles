# 我如何用 AI 处理历史遗留代码（暨 MiniMax M2.1 体验）

## 一、

最近，我写了好几篇 AI 教程，就收到留言，要我谈谈我自己的 AI 编程。

今天就来分享我的 AI 编程，也就是大家说的“氛围编程”（vibe coding）。

![](https://cdn.beekka.com/blogimg/asset/202512/bg2025122104.webp)

声明一下，我只是 AI 初级用户，除了不想藏私，更多是为了抛砖引玉，跟大家交流。

## 二、

首先，**我很少用 AI 生成新项目**。

我每次看 AI 产出的代码，总觉得那是别人的代码，不是我的。如果整个项目都用 AI 生成，潜意识里，我感觉不到那是自己的项目。我的习惯是，新项目的主体代码更愿意自己写。

**我主要把 AI 用在别人的项目和历史遗留代码**。

我建议大家也这样用，可以避免读懂他人代码的巨大成本。

就拿历史遗留代码为例，（1）很多时候没有足够的文档，也没有作者的说明，（2）技术栈和工具库都过时了，读懂代码还要翻找以前的标准，（3）最极端的情况下，只有构建产物，没有源代码，根本无法入手。

AI 简直就是这类代码的救星，再古老的代码，它都能读懂和修改，甚至还能对构建产物进行逆向工程。

下面就演示，我怎么用 AI 处理历史遗留代码，基本就是我平时的 AI 用法。

## 三、

我使用的 AI 编程工具是 Claude Code，因为[命令行](https://code.claude.com/docs/en/cli-reference)更方便，也容易跟其他工具集成。如果想在 IDE 里面调用 Claude Code，参考[这篇文章](https://github.com/cpp-linter/cpp-linter-action)。

我使用的 AI 模型，目前大多数时候是国产的 [MiniMax M2](https://www.minimaxi.com/)。我[测过](https://www.ruanyifeng.com/blog/2025/11/minimax-m2.html)它的功能，相当不错，能够满足需要，它的大模型排名也很靠前。

![](https://cdn.beekka.com/blogimg/asset/202512/bg2025122105.webp)

而且，它有包月价（29元人民币），可能是最便宜的编程模型之一，可以大量使用，反复试错。要是改用大家都趋之若鹜的 Claude 系列模型，20美元的 Pro 套餐不太够用，200美元的 Max 套餐又太贵。

MiniMax 接入 Claude Code 的方法，参考我的[这篇教程](https://www.ruanyifeng.com/blog/2025/11/doubao-seed-code.html)。

## 四、

就在我写这篇文章的时候，MiniMax 本周进行了一次大升级，**M2 模型升级到了 M2.1**。

这意味着，同样的价格现在可以用上更强大的模型。

因为跟自己相关，我挺关注这件事，仔细看了发布说明，本次升级主要有四处增强。

> **（1）多语言支持**（术语叫做 Multi-SWE），对于 Python、Go、TS、JS、Rust、Java、Cpp、C、Solidity 九种语言有专门强化。

> **（2）技术栈优化**，对于 WebDev、AppDev、Rust、Go、Java 等核心技术栈进行了专项优化。

> **（3）速度更快**，代码生成和推理速度都变快了，比 Gemini 3 Pro、Claude Opus 4.5、ChatGPT 5等模型都快。

> **（4）长程任务更出色**，指令遵循优化。

按照这个说明，对于常见编程任务，M2.1 的各方面都变强了。

这篇文章正好测一下，它的 Web 开发能力到底有没有变强。M2.1 接入 Claude Code 的参数如下。

![](https://cdn.beekka.com/blogimg/asset/202512/bg2025122201.webp)

## 五、

这次的历史遗留项目是 [wechat-format](https://github.com/ruanyf/wechat-format/)。它是一个 Web 应用，将 Markdown 文本转为微信公众号的样式。

![](https://cdn.beekka.com/blogimg/asset/202512/bg2025122101.webp)

上图左侧的文本框输入 Markdown 文本，右侧立刻展示自动渲染的结果，复制到微信公众号的编辑器即可。

它非常好用，大家可以去[试试看](https://ruanyf.github.io/wechat-format/)。我的公众号现在就用它做排版，效果不错。

![](https://cdn.beekka.com/blogimg/asset/202512/bg2025122202.webp)

问题是，原作者六年前就放弃了，这个项目不再更新了。我看过源码，它用的是老版本的 Vue.js 和 CodeMirror 编辑器，没有任何文档和说明，还经过了编译工具的处理。

如果不熟悉它的技术栈，想要修改这些代码是很困难的，可能要投入大量时间。

那么废话少说，直接让 AI 上场，把这些代码交给 MiniMax M2.1 模型。

## 六、

接手老项目的第一步，就是对项目进行一个总体的了解。

首先，让 AI 生成一个项目概述。大家可以跟着一起做，跟我的结果相对照。

```bash
# 克隆代码库
$ git clone git@github.com:ruanyf/wechat-format.git

# 进入项目目录
$ cd wechat-format

# 启动 Claude Code
$ claude-minimax
```

上面的`claude-minimax`是我的自定义命令，用来在 Claude Code 里面调用 MiniMax 模型（参见[教程](https://www.ruanyifeng.com/blog/2025/11/doubao-seed-code.html)）。

输入“生成这个仓库的概述”。

![](https://cdn.beekka.com/blogimg/asset/202512/bg2025122208.webp)

AI 很快就给出了详细说明，包括项目的总体介绍、核心功能、技术栈和文件结构（下图），相当有用。

![](https://cdn.beekka.com/blogimg/asset/202512/bg2025122209.webp)

有了总体了解以后，可以让 AI 解释主要脚本文件的代码。

> 解释 index.html 文件的代码

![](
https://cdn.beekka.com/blogimg/asset/202512/bg2025122206.webp)

它会给出代码结构和页面布局（上图），然后是 JS 脚本加载顺序和 Vue 应用逻辑，甚至包括了流程图（下图），这可是我没想到的。

![](
https://cdn.beekka.com/blogimg/asset/202512/bg2025122207.webp)

![](https://cdn.beekka.com/blogimg/asset/202512/bg2025122210.webp)

做完这一步，代码库的大致情况应该都有所了解了，而花费的时间不到一分钟。

## 七、

第二步就是调整代码，修改某些功能，让老项目能够满足现在的需要。

我们演示一个简单的修改，把链接颜色改掉，把默认的红色改成蓝色。原始代码中，颜色是写死的，根本没有留出修改的地方。

![](https://cdn.beekka.com/blogimg/asset/202512/bg2025122217.webp)

> 将默认主题的 a 元素颜色，从红色（#ff3502）改成蓝色（#0000FF）

![](https://cdn.beekka.com/blogimg/asset/202512/bg2025122211.webp)

AI 正确地发现了，链接分成两种情况：公众号内部链接和外部链接，它们渲染后的样式不一样。于是，把两种样式都改成了蓝色（下图）。

![](https://cdn.beekka.com/blogimg/asset/202512/bg2025122212.webp)

这时，AI 不仅会修改代码，还会有详细的说明，告诉你它做了什么。这一点真的好，方便理解和将来追溯，我们自己手写代码一般都懒得写这么详细的说明，这就是 AI 比人强的地方。

现在的页面链接，就从红色全部变成了蓝色（下图）。

![](https://cdn.beekka.com/blogimg/asset/202512/bg2025122216.webp)

## 八、

第三步就是为老代码添加一些原来的功能。

上一节说过，这个项目区分链接。如果是公众号内部链接，可以直接点击，否则就不能点击，而把 URL 加入文末列表（下图）。

![](https://cdn.beekka.com/blogimg/asset/202512/bg2025122213.webp)

我打算增加一段逻辑，让内部链接的 URL 也加入文末列表。

> 将 markdown 代码里面的微信公众号的链接，也加入页尾的链接列表

![](https://cdn.beekka.com/blogimg/asset/202512/bg2025122214.webp)

AI 很快给出了增删的代码（上图），同时也给出了详细的文字解释（下图）。

![](https://cdn.beekka.com/blogimg/asset/202512/bg2025122215.webp)

现在，公众号内部链接（即 mp.weixin.qq.com 域名下的链接），也会加入文末的链接列表了（下图）。

![](https://cdn.beekka.com/blogimg/asset/202512/bg2025122218.webp)

正常情况下，还需要为添加的功能补上单元测试。但是，这个示例比较简单，再加上原始项目本来就没测试脚本，这里也就省略了。

## 九、

历史遗留代码的 AI 处理，演示就到此为止。代码解释、代码修改、功能增加这三种情况都包括了，这就是我目前的 AI 编程的基本步骤了。

为了便于演示，我选择了这个比较简单的示例，如果人工来做上面这些事情，可能至少需要一个工作日，但是 AI 只需要十几分钟。

所以，以后遇到历史遗留代码，我一律建议先交给 AI。

至于这次体验的 MiniMax M2.1，我感觉不错。大家都看到了，我的提示词很简单，都是一句话，但是它正确理解了意图，基本一次就修改正确了。

而且，它就像发布说明介绍的一样，运行速度很快，整个思考过程和生成过程最多也就两三分钟，不像有的模型要等很久。

更令人满意的是，不管什么操作，它都会给出详细的讲解和代码注释。

总之，就我测试的情况来看，它的 Web 开发能力很不错，可以用于实际开发。

我还要补充一点，虽然这次的示例项目比较简单，不能完全测出它的能力，但是我认为这不是很重要。就像著名开发者 Simon Willison [最近说的](https://simonwillison.net/2025/Nov/24/claude-opus/)，评测大模型越来越困难，“我识别不出两个模型之间的实质性差异”，因为主流的新模型都已经足够强大，足以解决常见任务，只有不断升级评测的难度，才能测出它们的强弱。

这意味着，对于普通程序员的常见编程任务，不同模型不会构成重大差异，国产模型就很好用，完全没有必要迷信国外的旗舰模型。

（完）
